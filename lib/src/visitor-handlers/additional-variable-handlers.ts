import type { NodePath } from '@babel/core';
import { types as t } from '@babel/core';
import { notNullish } from '@ls-stack/utils/assertions';
import type { CssProcessingContext } from '../css-processing';
import { processGlobalStyle } from '../css-processing';
import { TransformError, TransformWarning } from '../custom-errors';
import {
  isValidHexColorWithoutAlpha,
  isVariableExported,
} from './handler-utils';

// Top-level regex to avoid creating new RegExp objects on each function call
const IDENTIFIER_REGEX = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

type VariableHandlerContext = {
  context: CssProcessingContext;
  dev: boolean;
  fileHash: string;
  classIndex: { current: number };
};

export function handleStaticThemeColorsAssignment(
  path: NodePath<t.VariableDeclarator>,
  handlerContext: VariableHandlerContext,
): boolean {
  const { context } = handlerContext;

  if (
    !context.state.vindurImports.has('createStaticThemeColors')
    || !path.node.init
    || !t.isCallExpression(path.node.init)
    || !t.isIdentifier(path.node.init.callee)
    || path.node.init.callee.name !== 'createStaticThemeColors'
    || path.node.init.arguments.length !== 1
    || !t.isIdentifier(path.node.id)
  ) {
    return false;
  }

  const varName = path.node.id.name;
  const argument = path.node.init.arguments[0];

  if (!argument || !t.isObjectExpression(argument)) {
    throw new TransformError(
      'createStaticThemeColors must be called with an object literal',
      notNullish(argument?.loc || path.node.loc),
    );
  }

  // Extract the color definitions
  const colors: Record<string, string> = {};
  for (const prop of argument.properties) {
    if (
      t.isObjectProperty(prop)
      && t.isIdentifier(prop.key)
      && t.isStringLiteral(prop.value)
    ) {
      const colorName = prop.key.name;
      const colorValue = prop.value.value;

      // Validate that the color is a valid hex color without alpha
      if (!isValidHexColorWithoutAlpha(colorValue)) {
        throw new TransformError(
          `Invalid color "${colorValue}" for "${colorName}". Theme colors must be valid hex colors without alpha (e.g., "#ff0000" or "#f00")`,
          notNullish(prop.value.loc),
        );
      }

      colors[colorName] = colorValue;
    } else {
      throw new TransformError(
        'createStaticThemeColors object must only contain string properties',
        notNullish(prop.loc),
      );
    }
  }

  // Store the theme colors for future reference
  context.state.themeColors ??= new Map();
  context.state.themeColors.set(varName, colors);

  // Replace the function call with the raw color object
  path.node.init = t.objectExpression(
    Object.entries(colors).map(([key, value]) =>
      t.objectProperty(
        key.match(IDENTIFIER_REGEX) ? t.identifier(key) : t.stringLiteral(key),
        t.stringLiteral(value),
      ),
    ),
  );

  return true;
}

export function handleDynamicCssColorAssignment(
  path: NodePath<t.VariableDeclarator>,
  handlerContext: VariableHandlerContext,
): boolean {
  const { context, dev, fileHash, classIndex } = handlerContext;

  if (
    !context.state.vindurImports.has('createDynamicCssColor')
    || !path.node.init
    || !t.isCallExpression(path.node.init)
    || !t.isIdentifier(path.node.init.callee)
    || path.node.init.callee.name !== 'createDynamicCssColor'
    || !t.isIdentifier(path.node.id)
  ) {
    return false;
  }

  // Check if any arguments are passed - this should throw an error
  if (path.node.init.arguments.length > 0) {
    throw new TransformError(
      'createDynamicCssColor() should not be called with an ID parameter. The ID is automatically generated by the compiler.',
      notNullish(path.node.init.loc),
    );
  }

  const varName = path.node.id.name;

  // Generate a unique hash ID for this dynamic color
  const dynamicColorId = `${fileHash}-${classIndex.current}`;
  classIndex.current++;

  // Store the dynamic color for future reference
  context.state.dynamicColors ??= new Map();
  context.state.dynamicColors.set(varName, dynamicColorId);

  // Replace the function call with the hashed ID and dev mode
  path.node.init = t.callExpression(t.identifier('createDynamicCssColor'), [
    t.stringLiteral(dynamicColorId),
    t.booleanLiteral(dev),
  ]);

  return true;
}

export function handleWithComponentAssignment(
  path: NodePath<t.VariableDeclarator>,
  handlerContext: VariableHandlerContext,
): boolean {
  const { context } = handlerContext;

  if (
    !context.state.vindurImports.has('styled')
    || !path.node.init
    || !t.isCallExpression(path.node.init)
    || !t.isMemberExpression(path.node.init.callee)
    || !t.isIdentifier(path.node.init.callee.object)
    || !t.isIdentifier(path.node.init.callee.property)
    || path.node.init.callee.property.name !== 'withComponent'
    || path.node.init.arguments.length !== 1
    || !t.isIdentifier(path.node.id)
  ) {
    return false;
  }

  // Handle Component.withComponent('element') variable assignments
  const varName = path.node.id.name;
  const baseComponentName = path.node.init.callee.object.name;
  const elementArg = path.node.init.arguments[0];

  // Handle both string literals (for DOM elements) and identifiers (for custom components)
  let newElementType: string;
  let isCustomComponent = false;

  if (t.isStringLiteral(elementArg)) {
    // DOM element: styled.button -> withComponent('div')
    newElementType = elementArg.value;
  } else if (t.isIdentifier(elementArg)) {
    // Custom component: MyButton -> withComponent(MyComponent)
    newElementType = elementArg.name;
    isCustomComponent = true;
  } else {
    throw new TransformError(
      'withComponent() must be called with either a string literal element name or a component identifier.',
      notNullish(elementArg?.loc || path.node.loc),
    );
  }

  // Get the base component info
  const baseComponentInfo =
    context.state.styledComponents.get(baseComponentName);
  if (!baseComponentInfo) {
    throw new TransformError(
      `Cannot call withComponent on "${baseComponentName}": it is not a styled component.`,
      notNullish(path.node.init.callee.object.loc),
    );
  }

  // Store the new styled component mapping with the new element type but same className
  // Components with attrs should always be treated as having intermediate components
  const isExported = isVariableExported(varName, path);
  const hasIntermediateComponent = isExported || !!baseComponentInfo.attrs;
  context.state.styledComponents.set(varName, {
    element: newElementType,
    className: baseComponentInfo.className,
    isExported,
    styleFlags: baseComponentInfo.styleFlags,
    attrs: baseComponentInfo.attrs,
    attrsExpression: baseComponentInfo.attrsExpression,
  });

  // Transform based on whether we have style flags and export status
  if (baseComponentInfo.styleFlags) {
    if (hasIntermediateComponent) {
      // Transform to _vCWM function call
      context.state.vindurImports.add('_vCWM');

      // Create the modifier array: [["propName", "hashedClassName"], ...]
      const modifierArray = t.arrayExpression(
        baseComponentInfo.styleFlags.map((styleProp) => {
          return t.arrayExpression([
            t.stringLiteral(styleProp.propName),
            t.stringLiteral(styleProp.hashedClassName),
          ]);
        }),
      );

      const vComponentArgs: t.Expression[] = [
        modifierArray,
        t.stringLiteral(baseComponentInfo.className),
        isCustomComponent ?
          t.identifier(newElementType)
        : t.stringLiteral(newElementType), // Pass component reference for custom components
      ];

      if (baseComponentInfo.attrsExpression) {
        vComponentArgs.push(baseComponentInfo.attrsExpression);
      }

      path.node.init = t.callExpression(t.identifier('_vCWM'), vComponentArgs);
    } else {
      // Local style-flagged component with withComponent: inline at usage, remove variable
      path.remove();
    }
  } else if (hasIntermediateComponent) {
    // Transform to _vSC function call
    context.state.vindurImports.add('_vSC');
    const styledComponentArgs: t.Expression[] = [
      isCustomComponent ?
        t.identifier(newElementType)
      : t.stringLiteral(newElementType), // Pass component reference for custom components
      t.stringLiteral(baseComponentInfo.className),
    ];

    if (baseComponentInfo.attrsExpression) {
      styledComponentArgs.push(baseComponentInfo.attrsExpression);
    }

    path.node.init = t.callExpression(
      t.identifier('_vSC'),
      styledComponentArgs,
    );
  } else {
    // Remove the withComponent declaration for local components
    path.remove();
  }

  return true;
}

export function handleGlobalStyleVariableAssignment(
  path: NodePath<t.VariableDeclarator>,
  handlerContext: VariableHandlerContext,
): boolean {
  const { context, dev, fileHash, classIndex } = handlerContext;

  if (
    !context.state.vindurImports.has('createGlobalStyle')
    || !path.node.init
    || !t.isTaggedTemplateExpression(path.node.init)
    || !t.isIdentifier(path.node.init.tag)
    || path.node.init.tag.name !== 'createGlobalStyle'
  ) {
    return false;
  }

  const result = processGlobalStyle(
    path.node.init.quasi,
    context,
    fileHash,
    classIndex,
  );

  // Emit warnings for scoped variables in dev mode
  if (
    dev
    && result.warnings
    && result.warnings.length > 0
    && context.onWarning
  ) {
    for (const warning of result.warnings) {
      const transformWarning = new TransformWarning(
        warning,
        notNullish(path.node.loc),
      );
      context.onWarning(transformWarning);
    }
  }

  // Remove the createGlobalStyle declaration since it doesn't produce a value
  path.remove();

  return true;
}
