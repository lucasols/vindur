export type StaticColor<D extends string> = {
  var: string;
  defaultHex: D;
  alpha: (alpha: number) => string;
  darker: (amount: number) => string;
  lighter: (amount: number) => string;
  saturatedDarker: (amount: number) => string;
  contrast: {
    var: string;
    optimal: (options?: { saturation?: number; alpha?: number }) => string;
    alpha: (alpha: number) => string;
  };
};

export type DynamicColorSet = {
  __color: string | null | false | undefined;
  __dynamicColorId: string;
};

export type DynamicCssColor = ColorOps & {
  setProps: (
    hexColor: string,
    options?: {
      style?: Record<string, unknown>;
      className?: string;
      setColorScheme?: { fallback: 'light' | 'dark' };
    },
  ) => { className: string; style: Record<string, unknown> };
  set: (color: string | null | false | undefined) => DynamicColorSet;
  _sp: (
    color: string | null | false | undefined,
    mergeWith: { className?: string; style?: Record<string, unknown> },
  ) => { className?: string; style?: Record<string, unknown> };
  self: {
    isDark: string;
    isLight: string;
    isDefined: string;
    isNotDefined: string;
    isVeryDark: string;
    isNotVeryDark: string;
    isVeryLight: string;
    isNotVeryLight: string;
  };
  container: {
    isDark: string;
    isLight: string;
    isDefined: string;
    isNotDefined: string;
    isVeryDark: string;
    isNotVeryDark: string;
    isVeryLight: string;
    isNotVeryLight: string;
  };
};

function hexToHsl(hex: string): { h: number; s: number; l: number } {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h: number;
  let s: number;
  const l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        h = 0;
    }
    h /= 6;
  }

  return { h: h * 360, s: s * 100, l: l * 100 };
}

function isLightColor(hex: string): boolean {
  const { l } = hexToHsl(hex);
  return l > 50;
}

function isDarkColor(hex: string): boolean {
  return !isLightColor(hex);
}

function isVeryDark(hex: string): boolean {
  const { l } = hexToHsl(hex);
  return l < 20;
}

function isVeryLight(hex: string): boolean {
  const { l } = hexToHsl(hex);
  return l > 80;
}

function getContrastColor(hex: string): string {
  return isLightColor(hex) ? '#000000' : '#ffffff';
}

export function createDynamicCssColor(hashId?: string, devMode?: boolean) {
  if (!hashId) {
    throw new Error(
      'createDynamicCssColor() cannot be called at runtime without compiler transformation. The ID is automatically generated by the compiler.',
    );
  }

  const selfConditions = [
    'is-dark',
    'is-light',
    'is-defined',
    'is-not-defined',
    'is-very-dark',
    'is-not-very-dark',
    'is-very-light',
    'is-not-very-light',
  ] as const;

  function getClassName(
    type: 'self' | 'container',
    condition: (typeof selfConditions)[number],
  ): string {
    if (devMode) return `${hashId}-${type}-${condition}`;
    const index = selfConditions.indexOf(condition);
    const shortType = type === 'self' ? 's' : 'c';
    return `${hashId}-${shortType}${index}`;
  }

  const ops = buildColorOps(
    `var(--${hashId})`,
    `var(--${hashId}-c)`,
    `var(--${hashId}-c-optimal)`,
  );

  const color: DynamicCssColor = {
    ...ops,
    setProps: (hexColor: string, options = {}) => {
      const colorClasses: string[] = [];

      if (isDarkColor(hexColor)) {
        colorClasses.push(getClassName('self', 'is-dark'));
      } else {
        colorClasses.push(getClassName('self', 'is-light'));
      }

      colorClasses.push(getClassName('self', 'is-defined'));

      if (isVeryDark(hexColor)) {
        colorClasses.push(getClassName('self', 'is-very-dark'));
      } else {
        colorClasses.push(getClassName('self', 'is-not-very-dark'));
      }

      if (isVeryLight(hexColor)) {
        colorClasses.push(getClassName('self', 'is-very-light'));
      } else {
        colorClasses.push(getClassName('self', 'is-not-very-light'));
      }

      const userClassName = options.className || '';
      const finalClassName =
        userClassName ?
          `${userClassName} ${colorClasses.join(' ')}`
        : colorClasses.join(' ');

      const contrastColor = getContrastColor(hexColor);
      const colorStyle: Record<string, unknown> = {
        [`--${hashId}`]: hexColor,
        [`--${hashId}-c`]: contrastColor,
        [`--${hashId}-c-optimal`]: contrastColor,
        ...options.style,
      };

      return { className: finalClassName, style: colorStyle };
    },
    self: {
      isDark: `&.${getClassName('self', 'is-dark')}`,
      isLight: `&.${getClassName('self', 'is-light')}`,
      isDefined: `&.${getClassName('self', 'is-defined')}`,
      isNotDefined: `&.${getClassName('self', 'is-not-defined')}`,
      isVeryDark: `&.${getClassName('self', 'is-very-dark')}`,
      isNotVeryDark: `&.${getClassName('self', 'is-not-very-dark')}`,
      isVeryLight: `&.${getClassName('self', 'is-very-light')}`,
      isNotVeryLight: `&.${getClassName('self', 'is-not-very-light')}`,
    },
    container: {
      isDark: `.${getClassName('container', 'is-dark')} &`,
      isLight: `.${getClassName('container', 'is-light')} &`,
      isDefined: `.${getClassName('container', 'is-defined')} &`,
      isNotDefined: `.${getClassName('container', 'is-not-defined')} &`,
      isVeryDark: `.${getClassName('container', 'is-very-dark')} &`,
      isNotVeryDark: `.${getClassName('container', 'is-not-very-dark')} &`,
      isVeryLight: `.${getClassName('container', 'is-very-light')} &`,
      isNotVeryLight: `.${getClassName('container', 'is-not-very-light')} &`,
    },
    set: (colorValue: string | null | false | undefined) => {
      console.error('color.set() should not be called at runtime');
      return { __color: colorValue, __dynamicColorId: hashId };
    },
    _sp: (
      colorValue: string | null | false | undefined,
      mergeWith: { className?: string; style?: Record<string, unknown> },
    ) => {
      if (!colorValue) return mergeWith;
      const colorProps = color.setProps(colorValue, {
        className: mergeWith.className,
        style: mergeWith.style ? mergeWith.style : undefined,
      });
      return { className: colorProps.className, style: colorProps.style };
    },
  };

  return color;
}

export function createStaticThemeColors<const C extends Record<string, string>>(
  colors: C,
): { [K in keyof C]: StaticColor<C[K]> } {
  const result: Record<string, StaticColor<string>> = {};

  for (const [name, hex] of Object.entries(colors)) {
    const contrastHex = getContrastColor(hex);
    const ops = buildColorOps(hex, contrastHex, contrastHex);
    result[name] = {
      defaultHex: hex,
      var: ops.var,
      alpha: ops.alpha,
      darker: ops.darker,
      lighter: ops.lighter,
      saturatedDarker: ops.saturatedDarker,
      contrast: ops.contrast,
    };
  }

  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- this a legit use case
  return result as unknown as { [K in keyof C]: StaticColor<C[K]> };
}

export type ContrastOps = {
  var: string;
  optimal: (options?: { saturation?: number; alpha?: number }) => string;
  alpha: (alpha: number) => string;
};

export type ColorOps = {
  var: string;
  alpha: (alpha: number) => string;
  darker: (amount: number) => string;
  lighter: (amount: number) => string;
  saturatedDarker: (amount: number) => string;
  contrast: ContrastOps;
};

export function buildColorOps(
  base: string,
  contrastBase: string,
  contrastOptimalBase: string,
): ColorOps {
  return {
    var: base,
    alpha: (alpha: number) =>
      `color-mix(in srgb, ${base} ${alpha * 100}%, transparent)`,
    darker: (amount: number) =>
      `color-mix(in srgb, ${base} ${(1 - amount) * 100}%, #000)`,
    lighter: (amount: number) =>
      `color-mix(in srgb, ${base} ${(1 - amount) * 100}%, #fff)`,
    saturatedDarker: (amount: number) =>
      `color-mix(in srgb, ${base} ${(1 - amount) * 100}%, hsl(from ${base} h 100% 20%))`,
    contrast: {
      var: contrastBase,
      optimal: (options?: { saturation?: number; alpha?: number }) => {
        if (options?.alpha) {
          return `color-mix(in srgb, ${contrastOptimalBase} ${options.alpha * 100}%, transparent)`;
        }
        return contrastOptimalBase;
      },
      alpha: (alpha: number) =>
        `color-mix(in srgb, ${contrastBase} ${alpha * 100}%, transparent)`,
    },
  };
}
